import { Component, OnInit } from '@angular/core';
import { Exam } from '../student/student.component';

@Component({
  
  selector: 'app-exams',
  templateUrl: './exams.component.html',
  styleUrls: ['./exams.component.css']
})
export class ExamsComponent implements OnInit {
  parts = [];
  exam:Exam = {
    Title:'Линукс',
    Questions: [
      '1. Понятие виртуальной сети. Виды виртуальных сетевых компонентов.',
      '2. Трансляция сетевых адресов. Виды NAT.',
      '3. Понятие сетевого сокета. Применение, виды, схема взаимодействия.',
      '4. Блокирующие и неблокирующие сокеты.'
      // '5. Транспортные протоколы TCP и UDP. Принципы работы, сравнение.',
      // '6. Клиент-серверное взаимодействие.',
      // '7. Реализация сокетов в языке Python. Модуль socket.',
      // '8. Понятие программного потока. Процессы и потоки.',
      // '9. Особенности реализации многопоточности в Python.Модуль threading.',
      // '10. Параллельное программирование. Достоинства и недостатки.',
      // '11. Понятие потокобезопасности. Причины, проблематика, способы обеспечения.',
      // '12. Алгоритм выполнения многопоточной программы. Блокировка потоков.',
      // '13. Доступ к общим ресурсам в многопоточной программе. Механизмы блокировки ресурсов модуля threading.',
      // '14. Понятие URL: назначение, применение, состав.',
      // '15. Понятие веб-сервера. Цели, принцип работы.',
      // '16. Протокол HTTP. Принцип работы, назначение, основные понятия.',
      // '17. Виртуальные хосты. Применение, настройка.',
      // '18. Системы управления содержимым. Назначение, принципы работы.',
      // '19. Понятие прокси-сервера. Настройка сервера nginx.',
      // '20. Администрирование дисковой подсистемы. LVM.',
      // '21. SSH. Назначение, схема работы, преимущества, недостатки.',
      // '22. SSH-форвардинг. Назначение, принципы работы.',
      // '23. Стандарт POSIX. Средства совместимости для ОС Windows.',
      // '24. Понятие управления конфигурациями.',
      // '25. Групповые политики'
    ],
    Answers:[
      'Виртуальной сетью называется группа узлов сети, трафик которой, в том числе и широковещательный, на канальном уровне полностью изолирован от других узлов сети. Это означает, что передача кадров между разными виртуальными сегментами на основании адреса канального уровня невозможна, независимо от типа адреса — уникального, группового или широковещательного. В то же время внутри виртуальной сети кадры передаются по технологии коммутации, то есть только на тот порт, который связан с адресом назначения кадра. Говорят, что виртуальная сеть образует домен широковещательного трафика (broadcast domain), по аналогии с доменом коллизий, который образуется повторителями сетей Ethernet.Назначение технологии виртуальных сетей состоит в облегчении процесса создания независимых сетей, которые затем должны связываться с помощью протоколов сетевого уровня. Для решения этой задачи до появления технологии виртуальных сетей использовались отдельные повторители, каждый из которых образовывал независимую сеть. Затем эти сети связывались маршрутизаторами в единую интерсеть. При изменении состава сегментов (переход пользователя в другую сеть, дробление крупных сегментов) при таком подходе приходится производить физическую перекоммутацию разъемов на передних панелях повторителей или в кроссовых панелях, что не очень удобно в больших сетях - много физической работы, к тому же высока вероятность ошибки.  При использовании технологии виртуальных сетей в коммутаторах одновременно решаются две задачи:* повышение производительности в каждой из виртуальных сетей, так как коммутатор передает кадры в такой сети только узлу назначения;* изоляция сетей друг от друга для управления правами доступа пользователей и создания защитных барьеров на пути широковещательных штормов.Для связи виртуальных сетей в интерсеть требуется привлечение сетевого уровня. Он может быть реализован в отдельном маршрутизаторе, а может работать и в составе программного обеспечения коммутатора.Существует несколько способов построения виртуальных сетей* Группировка портов.* Группировка МАС-адресов.* Использование меток в дополнительном поле кадра — частные протоколы и спецификации IEEE 802.1 Q/p.* Спецификация LANE для АТМ-комутаторов.* Использование сетевого уровня.',
      'Трансляция сетевых адресов (NAT) используется многими сервис провайдерами и частными пользователями для решения проблемы нехватки реальных IP-адресов и обеспечения безопасности локальных сетей подключенных к Интернету. Например. Предприятие может иметь выделенный диапазон реальных IP-адресов, но гораздобольшее количество компьютеров имеющих локальные IP-адреса которым необходим доступ в Интернет. Для решения этой проблемы используется технология трансляции адресов, которая позволяет компьютерам локальной сети взаимодействовать с сетью Интернет, используя всего один внешний реальный IP-адрес. NAT решает эту проблему с помощью подмены локального IP-адреса на наружный общедоступный адрес. Заменяя внутренний IP-адрес и порт на внешний IP-адрес и порт, NAT сохраняет таблицу соответствия, затем при получении ответного пакета производится обратное преобразование.Трансляторы адресов подразделяются на 4 типа: 1. Symmetric NAT.До недавнего времени это была наиболее распространённая реализация. Его характерная особенность – в таблице NAT маппинг адреса IL на адрес IG жёстко привязан к адресу OG, то есть к адресу назначения, который был указан в исходящем пакете, инициировавшем этот маппинг. При указанной реализации NAT в нашем примере хост 192.168.0.141 получит оттранслированные входящие UDP-пакеты только от хоста 1.2.3.4 и строго с портом источника 53 и портом назначения 1053 – ни от кого более. Пакеты от других хостов, даже если указанные в пакете адрес назначения и порт назначения присутствуют в таблице NAT, будут уничтожаться маршрутизатором.2. Full Cone NAT. Эта реализация NAT – полная противоположность предыдущей. При Full Cone NAT входящие пакеты от любого внешнего хоста будут оттранслированы и переправлены соответствующему хосту в локальной сети, если в таблице NAT присутствует соответствующая запись. Более того, номер порта источника в этом случае тоже не имеет значения – он может быть и 53, и 54, и вообще каким угодно. Например, если некое приложение, запущенное на компьютере в локальной сети, инициировало получение пакетов UDP от внешнего хоста 1.2.3.4 на локальный порт 4444, то пакеты UDP для этого приложения смогут слать также и 1.2.3.5, и 1.2.3.6, и вообще все до тех пор, пока запись в таблице NAT не будет по какой-либо причине удалена. 3. Address Restricted Cone NAT (он же Restricted NAT).      Эта реализация занимает промежуточное положение между Symmetric и Full Cone реализациями NAT – маршрутизатор будет транслировать входящие пакеты только с определенного адреса источника (в нашем случае 1.2.3.4), но номер порта источника при этом может быть любым. 4. Port Restricted Cone NAT (или Port Restricted NAT) То же, что и Address Restricted Cone NAT, но в этом случае маршрутизатор обращает внимание на соответствие номера порта источника и не обращает внимания на адрес источника. В нашем примере маршрутизатор будет транслировать входящие пакеты с любым адресом источника, но порт источника при этом обязан быть 53, в противном случае пакет будет уничтожен маршрутизатором.',
      'Совокупность IP-адреса и номера порта называется сокетом. Сокет однозначно идентифицирует прикладной процесс в сети TCP/IP. API сокетов – это название программного интерфейса, предназначенного для обмена данными между процессами, находящимися на одном или на разных объединенных сетью компьютерах. В операционной системе Windows интерфейс сокетов имеет название Windows Sockets API. API сокетов включает в себя функции создания сокета (имеется в виду объект операционной системы, описывающий соединение), установки параметров сокета (сетевой адрес, номер порта и т.д.), функции создания канала и обмена данными между сокетами. Кроме того, есть набор функций позволяющий управлять передачей данных, синхронизировать процессы передачи и приема данных, обрабатывать ошибки и т.п. сокет — это программный интерфейс для обеспечения информационного обмена между процессами. Но гораздо важнее не зазубрить определение, а понять суть. Поэтому я тут постараюсь рассказать все как можно подробнее и проще. Существуют клиентские и серверные сокеты. Вполне легко догадаться что к чему. Серверный сокет прослушивает определенный порт, а клиентский подключается к серверу. После того, как было установлено соединение начинается обмен данными. После успешной установки соединения сервер и клиент начинают обмениваться информацией. Например, сервер посылает приветствие и предложение ввести какую-либо команду. Клиент в свою очередь вводит команду, сервер ее анализирует, выполняет необходимые операции и отдает клиенту результат. В Python для работы с сокетами используется модуль socket:import socket Прежде всего нам необходимо создать сокет: sock = socket.socket() Насчет хоста — мы оставим строку пустой, чтобы наш сервер был доступен для всех интерфейсов. А порт возьмем любой от нуля до 65535. Теперь свяжем наш сокет с данными хостом и портом с помощью метода bind, которому передается кортеж, первый элемент (или нулевой, если считать от нуля) которого — хост, а второй — порт:  9090))С помощью метода listen мы запустим для данного сокета режим прослушивания. Метод принимает один аргумент — максимальное количество подключений в очереди. sock.listen(1) мы можем принять подключение с помощью метода accept, который возвращает кортеж с двумя элементами: новый сокет и адрес клиента. conn, addr = sock.accept() Закрыть соединение: conn.close()',
      'Сокеты бывают блокирующие и неблокирующие. Суть в том, что в случае блокирующих сокетов при попытке прочитать (и записать) данные функция чтения будет ждать до тех пор, пока не прочитает хотя бы один байт или произойдет разрыв соединения или придет сигнал. В случае неблокирующих сокетов функция чтения проверяет, есть ли данные в буфере, и если есть - сразу возвращает, если нет, то она не ждет и также сразу возвращает, что прочитано 0 байт. 5.7. ДОСТОИНСТВА БЛОКИРУЮЩЕГО РЕЖИМА Проще программировать - Блокирующие сокеты проще программировать. Весь пользовательский код может находиться в одном месте и выполняться в естественном, последовательном порядке. Кросс-платформенность – поскольку Unix использует блокирующие сокеты, по переносимый код легче писать. Indy использует данный факт для использования своего кода между платформами. Другие сокет компоненты, которые кросс платформенные, на самом деле эмулируют это с помощью внутреннего вызова блокирующих сокетов. Удобнее работать с потоками - Поскольку у блокирующих сокетов последовательность приобретена по наследственности, поэтому их очень просто использовать в потоках. Независимость от сообщений – неблокирующие сокеты зависят от системы оконных сообщений. Когда используются потоки, то создается отдельная очередь сообщений. Но когда потоки не используются, то узким местом становится обработка множества соединений. 5.8. НЕДОСТАТКИ БЛОКИРУЮЩЕГО РЕЖИМА Пользовательский интерфейс замораживается в клиентах - Вызов блокирующего сокета не возвращает управления, пока не выполнит свою задачу. Когда подобные вызовы делаются в главном кодовом потоке, то приложение замораживает пользовательский интерфейс. Замораживание происходит, поскольку сообщения обновления, перерисовки и другие сообщения не обрабатываются до окончания вызова блокирующего сокета. 5.10. ДОСТОИНСТВА НЕБЛОКИРУЮЩЕГО РЕЖИМА Пользовательский интерфейс не замораживается – поскольку пользовательский код обрабатывает оконные сообщения, то имеет контроль и над сокетными сообщениями. Поэтому Windows также может обрабатывать и другие сообщения. Многозадачность без использования потоков – используется единственный кодовый поток для обработки множества сокетов. Очень малая нагрузки при множестве сокетов – поскольку множество сокетов могут обрабатываться без потоков, то нагрузка на память и процессор значительно ниже. 5.11. НЕДОСТАТКИ НЕБЛОКИРУЮЩЕГО РЕЖИМА Более сложное программирование – неблокирующие сокеты требуют использования опроса или обработки событий. События наиболее используемый метод, а циклы опроса менее эффективны. При использовании обработчиков событий, код размазан по куче процедур, поэтому требуется отслеживание состояния. Это означает большее количество ошибок и более сложная модификация кода.'
    ]
  }
  constructor() { }

  ngOnInit() {
    for(let i = 0;i<this.exam.Questions.length;i++){
      this.parts.unshift(false);
    }
  }
  showPart(i){
    this.parts[i]=!this.parts[i];
  }

}
